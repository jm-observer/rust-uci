/* automatically generated by rust-bindgen 0.58.1 */

pub const UCI_CONFDIR : & 'static [u8 ; 12usize] = b"/etc/config\0" ; pub const UCI_SAVEDIR : & 'static [u8 ; 10usize] = b"/tmp/.uci\0" ; pub const UCI_DIRMODE : u32 = 448 ; pub const UCI_FILEMODE : u32 = 384 ; pub type __jmp_buf = [:: std :: os :: raw :: c_int ; 6usize] ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __sigset_t { pub __val : [:: std :: os :: raw :: c_ulong ; 32usize] , } # [test] fn bindgen_test_layout___sigset_t () { assert_eq ! (:: std :: mem :: size_of :: < __sigset_t > () , 128usize , concat ! ("Size of: " , stringify ! (__sigset_t))) ; assert_eq ! (:: std :: mem :: align_of :: < __sigset_t > () , 4usize , concat ! ("Alignment of " , stringify ! (__sigset_t))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < __sigset_t > ())) . __val as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (__sigset_t) , "::" , stringify ! (__val))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __jmp_buf_tag { pub __jmpbuf : __jmp_buf , pub __mask_was_saved : :: std :: os :: raw :: c_int , pub __saved_mask : __sigset_t , } # [test] fn bindgen_test_layout___jmp_buf_tag () { assert_eq ! (:: std :: mem :: size_of :: < __jmp_buf_tag > () , 156usize , concat ! ("Size of: " , stringify ! (__jmp_buf_tag))) ; assert_eq ! (:: std :: mem :: align_of :: < __jmp_buf_tag > () , 4usize , concat ! ("Alignment of " , stringify ! (__jmp_buf_tag))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < __jmp_buf_tag > ())) . __jmpbuf as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (__jmp_buf_tag) , "::" , stringify ! (__jmpbuf))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < __jmp_buf_tag > ())) . __mask_was_saved as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (__jmp_buf_tag) , "::" , stringify ! (__mask_was_saved))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < __jmp_buf_tag > ())) . __saved_mask as * const _ as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (__jmp_buf_tag) , "::" , stringify ! (__saved_mask))) ; } pub type jmp_buf = [__jmp_buf_tag ; 1usize] ; pub type size_t = :: std :: os :: raw :: c_uint ; pub type __uint32_t = :: std :: os :: raw :: c_uint ; pub type __int64_t = :: std :: os :: raw :: c_longlong ; pub type __off_t = :: std :: os :: raw :: c_long ; pub type __off64_t = __int64_t ; pub type FILE = _IO_FILE ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _IO_marker { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _IO_codecvt { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _IO_wide_data { _unused : [u8 ; 0] , } pub type _IO_lock_t = :: std :: os :: raw :: c_void ; # [repr (C)] # [derive (Copy , Clone)] pub struct _IO_FILE { pub _flags : :: std :: os :: raw :: c_int , pub _IO_read_ptr : * mut :: std :: os :: raw :: c_char , pub _IO_read_end : * mut :: std :: os :: raw :: c_char , pub _IO_read_base : * mut :: std :: os :: raw :: c_char , pub _IO_write_base : * mut :: std :: os :: raw :: c_char , pub _IO_write_ptr : * mut :: std :: os :: raw :: c_char , pub _IO_write_end : * mut :: std :: os :: raw :: c_char , pub _IO_buf_base : * mut :: std :: os :: raw :: c_char , pub _IO_buf_end : * mut :: std :: os :: raw :: c_char , pub _IO_save_base : * mut :: std :: os :: raw :: c_char , pub _IO_backup_base : * mut :: std :: os :: raw :: c_char , pub _IO_save_end : * mut :: std :: os :: raw :: c_char , pub _markers : * mut _IO_marker , pub _chain : * mut _IO_FILE , pub _fileno : :: std :: os :: raw :: c_int , pub _flags2 : :: std :: os :: raw :: c_int , pub _old_offset : __off_t , pub _cur_column : :: std :: os :: raw :: c_ushort , pub _vtable_offset : :: std :: os :: raw :: c_schar , pub _shortbuf : [:: std :: os :: raw :: c_char ; 1usize] , pub _lock : * mut _IO_lock_t , pub _offset : __off64_t , pub _codecvt : * mut _IO_codecvt , pub _wide_data : * mut _IO_wide_data , pub _freeres_list : * mut _IO_FILE , pub _freeres_buf : * mut :: std :: os :: raw :: c_void , pub __pad5 : size_t , pub _mode : :: std :: os :: raw :: c_int , pub _unused2 : [:: std :: os :: raw :: c_char ; 40usize] , } # [test] fn bindgen_test_layout__IO_FILE () { assert_eq ! (:: std :: mem :: size_of :: < _IO_FILE > () , 152usize , concat ! ("Size of: " , stringify ! (_IO_FILE))) ; assert_eq ! (:: std :: mem :: align_of :: < _IO_FILE > () , 8usize , concat ! ("Alignment of " , stringify ! (_IO_FILE))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _flags as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_flags))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _IO_read_ptr as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_IO_read_ptr))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _IO_read_end as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_IO_read_end))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _IO_read_base as * const _ as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_IO_read_base))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _IO_write_base as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_IO_write_base))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _IO_write_ptr as * const _ as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_IO_write_ptr))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _IO_write_end as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_IO_write_end))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _IO_buf_base as * const _ as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_IO_buf_base))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _IO_buf_end as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_IO_buf_end))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _IO_save_base as * const _ as usize } , 36usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_IO_save_base))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _IO_backup_base as * const _ as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_IO_backup_base))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _IO_save_end as * const _ as usize } , 44usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_IO_save_end))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _markers as * const _ as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_markers))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _chain as * const _ as usize } , 52usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_chain))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _fileno as * const _ as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_fileno))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _flags2 as * const _ as usize } , 60usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_flags2))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _old_offset as * const _ as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_old_offset))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _cur_column as * const _ as usize } , 68usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_cur_column))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _vtable_offset as * const _ as usize } , 70usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_vtable_offset))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _shortbuf as * const _ as usize } , 71usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_shortbuf))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _lock as * const _ as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_lock))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _offset as * const _ as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_offset))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _codecvt as * const _ as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_codecvt))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _wide_data as * const _ as usize } , 92usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_wide_data))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _freeres_list as * const _ as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_freeres_list))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _freeres_buf as * const _ as usize } , 100usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_freeres_buf))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . __pad5 as * const _ as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (__pad5))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _mode as * const _ as usize } , 108usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_mode))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < _IO_FILE > ())) . _unused2 as * const _ as usize } , 112usize , concat ! ("Offset of field: " , stringify ! (_IO_FILE) , "::" , stringify ! (_unused2))) ; } pub const UCI_OK : :: std :: os :: raw :: c_uint = 0 ; pub const UCI_ERR_MEM : :: std :: os :: raw :: c_uint = 1 ; pub const UCI_ERR_INVAL : :: std :: os :: raw :: c_uint = 2 ; pub const UCI_ERR_NOTFOUND : :: std :: os :: raw :: c_uint = 3 ; pub const UCI_ERR_IO : :: std :: os :: raw :: c_uint = 4 ; pub const UCI_ERR_PARSE : :: std :: os :: raw :: c_uint = 5 ; pub const UCI_ERR_DUPLICATE : :: std :: os :: raw :: c_uint = 6 ; pub const UCI_ERR_UNKNOWN : :: std :: os :: raw :: c_uint = 7 ; pub const UCI_ERR_LAST : :: std :: os :: raw :: c_uint = 8 ; pub type _bindgen_ty_1 = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct uci_list { pub next : * mut uci_list , pub prev : * mut uci_list , } # [test] fn bindgen_test_layout_uci_list () { assert_eq ! (:: std :: mem :: size_of :: < uci_list > () , 8usize , concat ! ("Size of: " , stringify ! (uci_list))) ; assert_eq ! (:: std :: mem :: align_of :: < uci_list > () , 4usize , concat ! ("Alignment of " , stringify ! (uci_list))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_list > ())) . next as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (uci_list) , "::" , stringify ! (next))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_list > ())) . prev as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (uci_list) , "::" , stringify ! (prev))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct uci_parse_context { _unused : [u8 ; 0] , } extern "C" { # [doc = " uci_alloc_context: Allocate a new uci context"] pub fn uci_alloc_context () -> * mut uci_context ; } extern "C" { # [doc = " uci_free_context: Free the uci context including all of its data"] pub fn uci_free_context (ctx : * mut uci_context) ; } extern "C" { # [doc = " uci_perror: Print the last uci error that occured"] # [doc = " @ctx: uci context"] # [doc = " @str: string to print before the error message"] pub fn uci_perror (ctx : * mut uci_context , str_ : * const :: std :: os :: raw :: c_char) ; } extern "C" { # [doc = " uci_geterror: Get an error string for the last uci error"] # [doc = " @ctx: uci context"] # [doc = " @dest: target pointer for the string"] # [doc = " @str: prefix for the error message"] # [doc = ""] # [doc = " Note: string must be freed by the caller"] pub fn uci_get_errorstr (ctx : * mut uci_context , dest : * mut * mut :: std :: os :: raw :: c_char , str_ : * const :: std :: os :: raw :: c_char) ; } extern "C" { # [doc = " uci_import: Import uci config data from a stream"] # [doc = " @ctx: uci context"] # [doc = " @stream: file stream to import from"] # [doc = " @name: (optional) assume the config has the given name"] # [doc = " @package: (optional) store the last parsed config package in this variable"] # [doc = " @single: ignore the 'package' keyword and parse everything into a single package"] # [doc = ""] # [doc = " the name parameter is for config files that don't explicitly use the 'package <...>' keyword"] # [doc = " if 'package' points to a non-null struct pointer, enable delta tracking and merge"] pub fn uci_import (ctx : * mut uci_context , stream : * mut FILE , name : * const :: std :: os :: raw :: c_char , package : * mut * mut uci_package , single : bool) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " uci_export: Export one or all uci config packages"] # [doc = " @ctx: uci context"] # [doc = " @stream: output stream"] # [doc = " @package: (optional) uci config package to export"] # [doc = " @header: include the package header"] pub fn uci_export (ctx : * mut uci_context , stream : * mut FILE , package : * mut uci_package , header : bool) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " uci_load: Parse an uci config file and store it in the uci context"] # [doc = ""] # [doc = " @ctx: uci context"] # [doc = " @name: name of the config file (relative to the config directory)"] # [doc = " @package: store the loaded config package in this variable"] pub fn uci_load (ctx : * mut uci_context , name : * const :: std :: os :: raw :: c_char , package : * mut * mut uci_package) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " uci_unload: Unload a config file from the uci context"] # [doc = ""] # [doc = " @ctx: uci context"] # [doc = " @package: pointer to the uci_package struct"] pub fn uci_unload (ctx : * mut uci_context , p : * mut uci_package) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " uci_lookup_ptr: Split an uci tuple string and look up an element tree"] # [doc = " @ctx: uci context"] # [doc = " @ptr: lookup result struct"] # [doc = " @str: uci tuple string to look up"] # [doc = " @extended: allow extended syntax lookup"] # [doc = ""] # [doc = " if extended is set to true, uci_lookup_ptr supports the following"] # [doc = " extended syntax:"] # [doc = ""] # [doc = " Examples:"] # [doc = "   network.@interface[0].ifname ('ifname' option of the first interface section)"] # [doc = "   network.@interface[-1]       (last interface section)"] # [doc = " Note: uci_lookup_ptr will automatically load a config package if necessary"] # [doc = " @str must not be constant, as it will be modified and used for the strings inside @ptr,"] # [doc = " thus it must also be available as long as @ptr is in use."] # [doc = ""] # [doc = " This function returns UCI_ERR_NOTFOUND if the package specified in the tuple"] # [doc = " string cannot be found.  Otherwise it will return UCI_OK."] # [doc = ""] # [doc = " Note that failures in looking up other parts, if they are also specfied,"] # [doc = " including section and option, will also have a return value UCI_OK but with"] # [doc = " ptr->flags * UCI_LOOKUP_COMPLETE not set."] pub fn uci_lookup_ptr (ctx : * mut uci_context , ptr : * mut uci_ptr , str_ : * mut :: std :: os :: raw :: c_char , extended : bool) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " uci_add_section: Add an unnamed section"] # [doc = " @ctx: uci context"] # [doc = " @p: package to add the section to"] # [doc = " @type: section type"] # [doc = " @res: pointer to store a reference to the new section in"] pub fn uci_add_section (ctx : * mut uci_context , p : * mut uci_package , type_ : * const :: std :: os :: raw :: c_char , res : * mut * mut uci_section) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " uci_set: Set an element's value; create the element if necessary"] # [doc = " @ctx: uci context"] # [doc = " @ptr: uci pointer"] # [doc = ""] # [doc = " The updated/created element is stored in ptr->last"] pub fn uci_set (ctx : * mut uci_context , ptr : * mut uci_ptr) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " uci_add_list: Append a string to an element list"] # [doc = " @ctx: uci context"] # [doc = " @ptr: uci pointer (with value)"] # [doc = ""] # [doc = " Note: if the given option already contains a string value,"] # [doc = " it will be converted to an 1-element-list before appending the next element"] pub fn uci_add_list (ctx : * mut uci_context , ptr : * mut uci_ptr) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " uci_del_list: Remove a string from an element list"] # [doc = " @ctx: uci context"] # [doc = " @ptr: uci pointer (with value)"] # [doc = ""] pub fn uci_del_list (ctx : * mut uci_context , ptr : * mut uci_ptr) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " uci_reorder: Reposition a section"] # [doc = " @ctx: uci context"] # [doc = " @s: uci section to reposition"] # [doc = " @pos: new position in the section list"] pub fn uci_reorder_section (ctx : * mut uci_context , s : * mut uci_section , pos : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " uci_rename: Rename an element"] # [doc = " @ctx: uci context"] # [doc = " @ptr: uci pointer (with value)"] pub fn uci_rename (ctx : * mut uci_context , ptr : * mut uci_ptr) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " uci_delete: Delete a section or option"] # [doc = " @ctx: uci context"] # [doc = " @ptr: uci pointer"] pub fn uci_delete (ctx : * mut uci_context , ptr : * mut uci_ptr) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " uci_save: save change delta for a package"] # [doc = " @ctx: uci context"] # [doc = " @p: uci_package struct"] pub fn uci_save (ctx : * mut uci_context , p : * mut uci_package) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " uci_commit: commit changes to a package"] # [doc = " @ctx: uci context"] # [doc = " @p: uci_package struct pointer"] # [doc = " @overwrite: overwrite existing config data and flush delta"] # [doc = ""] # [doc = " committing may reload the whole uci_package data,"] # [doc = " the supplied pointer is updated accordingly"] pub fn uci_commit (ctx : * mut uci_context , p : * mut * mut uci_package , overwrite : bool) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " uci_list_configs: List available uci config files"] # [doc = " @ctx: uci context"] # [doc = ""] # [doc = " caller is responsible for freeing the allocated memory behind list"] pub fn uci_list_configs (ctx : * mut uci_context , list : * mut * mut * mut :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " uci_set_savedir: override the default delta save directory"] # [doc = " @ctx: uci context"] # [doc = " @dir: directory name"] # [doc = ""] # [doc = " This will also try adding the specified dir to the end of delta pathes."] pub fn uci_set_savedir (ctx : * mut uci_context , dir : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " uci_set_savedir: override the default config storage directory"] # [doc = " @ctx: uci context"] # [doc = " @dir: directory name"] pub fn uci_set_confdir (ctx : * mut uci_context , dir : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " uci_add_delta_path: add a directory to the search path for change delta files"] # [doc = " @ctx: uci context"] # [doc = " @dir: directory name"] # [doc = ""] # [doc = " This function allows you to add directories, which contain 'overlays'"] # [doc = " for the active config, that will never be committed."] # [doc = ""] # [doc = " Adding a duplicate directory will cause UCI_ERR_DUPLICATE be returned."] pub fn uci_add_delta_path (ctx : * mut uci_context , dir : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " uci_revert: revert all changes to a config item"] # [doc = " @ctx: uci context"] # [doc = " @ptr: uci pointer"] pub fn uci_revert (ctx : * mut uci_context , ptr : * mut uci_ptr) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " uci_parse_argument: parse a shell-style argument, with an arbitrary quoting style"] # [doc = " @ctx: uci context"] # [doc = " @stream: input stream"] # [doc = " @str: pointer to the current line (use NULL for parsing the next line)"] # [doc = " @result: pointer for the result"] pub fn uci_parse_argument (ctx : * mut uci_context , stream : * mut FILE , str_ : * mut * mut :: std :: os :: raw :: c_char , result : * mut * mut :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " uci_set_backend: change the default backend"] # [doc = " @ctx: uci context"] # [doc = " @name: name of the backend"] # [doc = ""] # [doc = " The default backend is \"file\", which uses /etc/config for config storage"] pub fn uci_set_backend (ctx : * mut uci_context , name : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " uci_validate_text: validate a value string for uci options"] # [doc = " @str: value"] # [doc = ""] # [doc = " this function checks whether a given string is acceptable as value"] # [doc = " for uci options"] pub fn uci_validate_text (str_ : * const :: std :: os :: raw :: c_char) -> bool ; } extern "C" { # [doc = " uci_parse_ptr: parse a uci string into a uci_ptr"] # [doc = " @ctx: uci context"] # [doc = " @ptr: target data structure"] # [doc = " @str: string to parse"] # [doc = ""] # [doc = " str is modified by this function"] pub fn uci_parse_ptr (ctx : * mut uci_context , ptr : * mut uci_ptr , str_ : * mut :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " uci_lookup_next: lookup a child element"] # [doc = " @ctx: uci context"] # [doc = " @e: target element pointer"] # [doc = " @list: list of elements"] # [doc = " @name: name of the child element"] # [doc = ""] # [doc = " if parent is NULL, the function looks up the package with the given name"] pub fn uci_lookup_next (ctx : * mut uci_context , e : * mut * mut uci_element , list : * mut uci_list , name : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " uci_parse_section: look up a set of options"] # [doc = " @s: uci section"] # [doc = " @opts: list of options to look up"] # [doc = " @n_opts: number of options to look up"] # [doc = " @tb: array of pointers to found options"] pub fn uci_parse_section (s : * mut uci_section , opts : * const uci_parse_option , n_opts : :: std :: os :: raw :: c_int , tb : * mut * mut uci_option) ; } extern "C" { # [doc = " uci_hash_options: build a hash over a list of options"] # [doc = " @tb: list of option pointers"] # [doc = " @n_opts: number of options"] pub fn uci_hash_options (tb : * mut * mut uci_option , n_opts : :: std :: os :: raw :: c_int) -> u32 ; } pub const uci_type_UCI_TYPE_UNSPEC : uci_type = 0 ; pub const uci_type_UCI_TYPE_DELTA : uci_type = 1 ; pub const uci_type_UCI_TYPE_PACKAGE : uci_type = 2 ; pub const uci_type_UCI_TYPE_SECTION : uci_type = 3 ; pub const uci_type_UCI_TYPE_OPTION : uci_type = 4 ; pub const uci_type_UCI_TYPE_PATH : uci_type = 5 ; pub const uci_type_UCI_TYPE_BACKEND : uci_type = 6 ; pub const uci_type_UCI_TYPE_ITEM : uci_type = 7 ; pub const uci_type_UCI_TYPE_HOOK : uci_type = 8 ; pub type uci_type = :: std :: os :: raw :: c_uint ; pub const uci_option_type_UCI_TYPE_STRING : uci_option_type = 0 ; pub const uci_option_type_UCI_TYPE_LIST : uci_option_type = 1 ; pub type uci_option_type = :: std :: os :: raw :: c_uint ; pub const uci_flags_UCI_FLAG_STRICT : uci_flags = 1 ; pub const uci_flags_UCI_FLAG_PERROR : uci_flags = 2 ; pub const uci_flags_UCI_FLAG_EXPORT_NAME : uci_flags = 4 ; pub const uci_flags_UCI_FLAG_SAVED_DELTA : uci_flags = 8 ; pub type uci_flags = :: std :: os :: raw :: c_uint ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct uci_element { pub list : uci_list , pub type_ : uci_type , pub name : * mut :: std :: os :: raw :: c_char , } # [test] fn bindgen_test_layout_uci_element () { assert_eq ! (:: std :: mem :: size_of :: < uci_element > () , 16usize , concat ! ("Size of: " , stringify ! (uci_element))) ; assert_eq ! (:: std :: mem :: align_of :: < uci_element > () , 4usize , concat ! ("Alignment of " , stringify ! (uci_element))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_element > ())) . list as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (uci_element) , "::" , stringify ! (list))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_element > ())) . type_ as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (uci_element) , "::" , stringify ! (type_))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_element > ())) . name as * const _ as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (uci_element) , "::" , stringify ! (name))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct uci_backend { pub e : uci_element , pub list_configs : :: std :: option :: Option < unsafe extern "C" fn (ctx : * mut uci_context) -> * mut * mut :: std :: os :: raw :: c_char > , pub load : :: std :: option :: Option < unsafe extern "C" fn (ctx : * mut uci_context , name : * const :: std :: os :: raw :: c_char) -> * mut uci_package > , pub commit : :: std :: option :: Option < unsafe extern "C" fn (ctx : * mut uci_context , p : * mut * mut uci_package , overwrite : bool) > , pub ptr : * const :: std :: os :: raw :: c_void , pub priv_ : * mut :: std :: os :: raw :: c_void , } # [test] fn bindgen_test_layout_uci_backend () { assert_eq ! (:: std :: mem :: size_of :: < uci_backend > () , 36usize , concat ! ("Size of: " , stringify ! (uci_backend))) ; assert_eq ! (:: std :: mem :: align_of :: < uci_backend > () , 4usize , concat ! ("Alignment of " , stringify ! (uci_backend))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_backend > ())) . e as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (uci_backend) , "::" , stringify ! (e))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_backend > ())) . list_configs as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (uci_backend) , "::" , stringify ! (list_configs))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_backend > ())) . load as * const _ as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (uci_backend) , "::" , stringify ! (load))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_backend > ())) . commit as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (uci_backend) , "::" , stringify ! (commit))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_backend > ())) . ptr as * const _ as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (uci_backend) , "::" , stringify ! (ptr))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_backend > ())) . priv_ as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (uci_backend) , "::" , stringify ! (priv_))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct uci_context { pub root : uci_list , pub pctx : * mut uci_parse_context , pub backend : * mut uci_backend , pub backends : uci_list , pub flags : uci_flags , pub confdir : * mut :: std :: os :: raw :: c_char , pub savedir : * mut :: std :: os :: raw :: c_char , pub delta_path : uci_list , pub err : :: std :: os :: raw :: c_int , pub func : * const :: std :: os :: raw :: c_char , pub trap : jmp_buf , pub internal : bool , pub nested : bool , pub buf : * mut :: std :: os :: raw :: c_char , pub bufsz : :: std :: os :: raw :: c_int , } # [test] fn bindgen_test_layout_uci_context () { assert_eq ! (:: std :: mem :: size_of :: < uci_context > () , 220usize , concat ! ("Size of: " , stringify ! (uci_context))) ; assert_eq ! (:: std :: mem :: align_of :: < uci_context > () , 4usize , concat ! ("Alignment of " , stringify ! (uci_context))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_context > ())) . root as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (uci_context) , "::" , stringify ! (root))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_context > ())) . pctx as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (uci_context) , "::" , stringify ! (pctx))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_context > ())) . backend as * const _ as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (uci_context) , "::" , stringify ! (backend))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_context > ())) . backends as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (uci_context) , "::" , stringify ! (backends))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_context > ())) . flags as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (uci_context) , "::" , stringify ! (flags))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_context > ())) . confdir as * const _ as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (uci_context) , "::" , stringify ! (confdir))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_context > ())) . savedir as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (uci_context) , "::" , stringify ! (savedir))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_context > ())) . delta_path as * const _ as usize } , 36usize , concat ! ("Offset of field: " , stringify ! (uci_context) , "::" , stringify ! (delta_path))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_context > ())) . err as * const _ as usize } , 44usize , concat ! ("Offset of field: " , stringify ! (uci_context) , "::" , stringify ! (err))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_context > ())) . func as * const _ as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (uci_context) , "::" , stringify ! (func))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_context > ())) . trap as * const _ as usize } , 52usize , concat ! ("Offset of field: " , stringify ! (uci_context) , "::" , stringify ! (trap))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_context > ())) . internal as * const _ as usize } , 208usize , concat ! ("Offset of field: " , stringify ! (uci_context) , "::" , stringify ! (internal))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_context > ())) . nested as * const _ as usize } , 209usize , concat ! ("Offset of field: " , stringify ! (uci_context) , "::" , stringify ! (nested))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_context > ())) . buf as * const _ as usize } , 212usize , concat ! ("Offset of field: " , stringify ! (uci_context) , "::" , stringify ! (buf))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_context > ())) . bufsz as * const _ as usize } , 216usize , concat ! ("Offset of field: " , stringify ! (uci_context) , "::" , stringify ! (bufsz))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct uci_package { pub e : uci_element , pub sections : uci_list , pub ctx : * mut uci_context , pub has_delta : bool , pub path : * mut :: std :: os :: raw :: c_char , pub backend : * mut uci_backend , pub priv_ : * mut :: std :: os :: raw :: c_void , pub n_section : :: std :: os :: raw :: c_int , pub delta : uci_list , pub saved_delta : uci_list , } # [test] fn bindgen_test_layout_uci_package () { assert_eq ! (:: std :: mem :: size_of :: < uci_package > () , 64usize , concat ! ("Size of: " , stringify ! (uci_package))) ; assert_eq ! (:: std :: mem :: align_of :: < uci_package > () , 4usize , concat ! ("Alignment of " , stringify ! (uci_package))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_package > ())) . e as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (uci_package) , "::" , stringify ! (e))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_package > ())) . sections as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (uci_package) , "::" , stringify ! (sections))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_package > ())) . ctx as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (uci_package) , "::" , stringify ! (ctx))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_package > ())) . has_delta as * const _ as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (uci_package) , "::" , stringify ! (has_delta))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_package > ())) . path as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (uci_package) , "::" , stringify ! (path))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_package > ())) . backend as * const _ as usize } , 36usize , concat ! ("Offset of field: " , stringify ! (uci_package) , "::" , stringify ! (backend))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_package > ())) . priv_ as * const _ as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (uci_package) , "::" , stringify ! (priv_))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_package > ())) . n_section as * const _ as usize } , 44usize , concat ! ("Offset of field: " , stringify ! (uci_package) , "::" , stringify ! (n_section))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_package > ())) . delta as * const _ as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (uci_package) , "::" , stringify ! (delta))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_package > ())) . saved_delta as * const _ as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (uci_package) , "::" , stringify ! (saved_delta))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct uci_section { pub e : uci_element , pub options : uci_list , pub package : * mut uci_package , pub anonymous : bool , pub type_ : * mut :: std :: os :: raw :: c_char , } # [test] fn bindgen_test_layout_uci_section () { assert_eq ! (:: std :: mem :: size_of :: < uci_section > () , 36usize , concat ! ("Size of: " , stringify ! (uci_section))) ; assert_eq ! (:: std :: mem :: align_of :: < uci_section > () , 4usize , concat ! ("Alignment of " , stringify ! (uci_section))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_section > ())) . e as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (uci_section) , "::" , stringify ! (e))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_section > ())) . options as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (uci_section) , "::" , stringify ! (options))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_section > ())) . package as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (uci_section) , "::" , stringify ! (package))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_section > ())) . anonymous as * const _ as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (uci_section) , "::" , stringify ! (anonymous))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_section > ())) . type_ as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (uci_section) , "::" , stringify ! (type_))) ; } # [repr (C)] # [derive (Copy , Clone)] pub struct uci_option { pub e : uci_element , pub section : * mut uci_section , pub type_ : uci_option_type , pub v : uci_option__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] pub union uci_option__bindgen_ty_1 { pub list : uci_list , pub string : * mut :: std :: os :: raw :: c_char , } # [test] fn bindgen_test_layout_uci_option__bindgen_ty_1 () { assert_eq ! (:: std :: mem :: size_of :: < uci_option__bindgen_ty_1 > () , 8usize , concat ! ("Size of: " , stringify ! (uci_option__bindgen_ty_1))) ; assert_eq ! (:: std :: mem :: align_of :: < uci_option__bindgen_ty_1 > () , 4usize , concat ! ("Alignment of " , stringify ! (uci_option__bindgen_ty_1))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_option__bindgen_ty_1 > ())) . list as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (uci_option__bindgen_ty_1) , "::" , stringify ! (list))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_option__bindgen_ty_1 > ())) . string as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (uci_option__bindgen_ty_1) , "::" , stringify ! (string))) ; } # [test] fn bindgen_test_layout_uci_option () { assert_eq ! (:: std :: mem :: size_of :: < uci_option > () , 32usize , concat ! ("Size of: " , stringify ! (uci_option))) ; assert_eq ! (:: std :: mem :: align_of :: < uci_option > () , 4usize , concat ! ("Alignment of " , stringify ! (uci_option))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_option > ())) . e as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (uci_option) , "::" , stringify ! (e))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_option > ())) . section as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (uci_option) , "::" , stringify ! (section))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_option > ())) . type_ as * const _ as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (uci_option) , "::" , stringify ! (type_))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_option > ())) . v as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (uci_option) , "::" , stringify ! (v))) ; } pub const uci_command_UCI_CMD_ADD : uci_command = 0 ; pub const uci_command_UCI_CMD_REMOVE : uci_command = 1 ; pub const uci_command_UCI_CMD_CHANGE : uci_command = 2 ; pub const uci_command_UCI_CMD_RENAME : uci_command = 3 ; pub const uci_command_UCI_CMD_REORDER : uci_command = 4 ; pub const uci_command_UCI_CMD_LIST_ADD : uci_command = 5 ; pub const uci_command_UCI_CMD_LIST_DEL : uci_command = 6 ; pub const uci_command___UCI_CMD_MAX : uci_command = 7 ; pub const uci_command___UCI_CMD_LAST : uci_command = 6 ; pub type uci_command = :: std :: os :: raw :: c_uint ; extern "C" { pub static mut uci_command_char : [:: std :: os :: raw :: c_char ; 0usize] ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct uci_delta { pub e : uci_element , pub cmd : uci_command , pub section : * mut :: std :: os :: raw :: c_char , pub value : * mut :: std :: os :: raw :: c_char , } # [test] fn bindgen_test_layout_uci_delta () { assert_eq ! (:: std :: mem :: size_of :: < uci_delta > () , 28usize , concat ! ("Size of: " , stringify ! (uci_delta))) ; assert_eq ! (:: std :: mem :: align_of :: < uci_delta > () , 4usize , concat ! ("Alignment of " , stringify ! (uci_delta))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_delta > ())) . e as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (uci_delta) , "::" , stringify ! (e))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_delta > ())) . cmd as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (uci_delta) , "::" , stringify ! (cmd))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_delta > ())) . section as * const _ as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (uci_delta) , "::" , stringify ! (section))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_delta > ())) . value as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (uci_delta) , "::" , stringify ! (value))) ; } # [repr (C)] # [derive (Copy , Clone)] pub struct uci_ptr { pub target : uci_type , pub flags : uci_ptr__bindgen_ty_1 , pub p : * mut uci_package , pub s : * mut uci_section , pub o : * mut uci_option , pub last : * mut uci_element , pub package : * const :: std :: os :: raw :: c_char , pub section : * const :: std :: os :: raw :: c_char , pub option : * const :: std :: os :: raw :: c_char , pub value : * const :: std :: os :: raw :: c_char , } pub const uci_ptr_UCI_LOOKUP_DONE : :: std :: os :: raw :: c_uint = 1 ; pub const uci_ptr_UCI_LOOKUP_COMPLETE : :: std :: os :: raw :: c_uint = 2 ; pub const uci_ptr_UCI_LOOKUP_EXTENDED : :: std :: os :: raw :: c_uint = 4 ; pub type uci_ptr__bindgen_ty_1 = :: std :: os :: raw :: c_uint ; # [test] fn bindgen_test_layout_uci_ptr () { assert_eq ! (:: std :: mem :: size_of :: < uci_ptr > () , 40usize , concat ! ("Size of: " , stringify ! (uci_ptr))) ; assert_eq ! (:: std :: mem :: align_of :: < uci_ptr > () , 4usize , concat ! ("Alignment of " , stringify ! (uci_ptr))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_ptr > ())) . target as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (uci_ptr) , "::" , stringify ! (target))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_ptr > ())) . flags as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (uci_ptr) , "::" , stringify ! (flags))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_ptr > ())) . p as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (uci_ptr) , "::" , stringify ! (p))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_ptr > ())) . s as * const _ as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (uci_ptr) , "::" , stringify ! (s))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_ptr > ())) . o as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (uci_ptr) , "::" , stringify ! (o))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_ptr > ())) . last as * const _ as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (uci_ptr) , "::" , stringify ! (last))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_ptr > ())) . package as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (uci_ptr) , "::" , stringify ! (package))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_ptr > ())) . section as * const _ as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (uci_ptr) , "::" , stringify ! (section))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_ptr > ())) . option as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (uci_ptr) , "::" , stringify ! (option))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_ptr > ())) . value as * const _ as usize } , 36usize , concat ! ("Offset of field: " , stringify ! (uci_ptr) , "::" , stringify ! (value))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct uci_parse_option { pub name : * const :: std :: os :: raw :: c_char , pub type_ : uci_option_type , } # [test] fn bindgen_test_layout_uci_parse_option () { assert_eq ! (:: std :: mem :: size_of :: < uci_parse_option > () , 8usize , concat ! ("Size of: " , stringify ! (uci_parse_option))) ; assert_eq ! (:: std :: mem :: align_of :: < uci_parse_option > () , 4usize , concat ! ("Alignment of " , stringify ! (uci_parse_option))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_parse_option > ())) . name as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (uci_parse_option) , "::" , stringify ! (name))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < uci_parse_option > ())) . type_ as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (uci_parse_option) , "::" , stringify ! (type_))) ; }